# Trace ID Logging

SRouter provides built-in support for trace ID logging, which is crucial for correlating log entries across different parts of your application (and potentially across microservices) for a single incoming request.

When enabled, SRouter automatically assigns a unique trace ID (a UUID) to each incoming request. This trace ID is then:

1.  Added to the request's context.
2.  Included in all log messages generated by SRouter's internal logging when `EnableTraceLogging` is true.
3.  Made accessible to your handlers and middleware.

## Enabling Trace ID Logging

Trace ID generation and injection into the context is enabled by setting `TraceIDBufferSize` in `RouterConfig` to a value greater than 0. This internally creates an ID generator and adds the necessary trace middleware.

```go
routerConfig := router.RouterConfig{
    Logger:            logger, // Assume logger exists
    TraceIDBufferSize: 1000,   // Enable trace ID generation with a buffer size
    // Other configuration...
}
r := router.NewRouter[string, string](routerConfig, authFunction, userIdFromUserFunction) // Assume auth funcs exist
```

Setting `TraceIDBufferSize` to 0 disables automatic trace ID generation and middleware addition.

Alternatively, you can manage the trace middleware explicitly:

1.  Set `TraceIDBufferSize: 0` in `RouterConfig`.
2.  Create an `*middleware.IDGenerator` instance using `middleware.NewIDGenerator(bufferSize)`.
3.  Create the middleware using `middleware.CreateTraceMiddleware(idGen)`.
4.  Add the created middleware to `RouterConfig.Middlewares` (usually as the first one).

```go
import "github.com/Suhaibinator/SRouter/pkg/middleware"
import "github.com/Suhaibinator/SRouter/pkg/common"

idGenerator := middleware.NewIDGenerator(1000) // Create generator
traceMiddleware := middleware.CreateTraceMiddleware(idGenerator) // Create middleware

routerConfig := router.RouterConfig{
    Logger:            logger, // Assume logger exists
    TraceIDBufferSize: 0,      // Disable automatic handling
    Middlewares: []common.Middleware{
        traceMiddleware, // Add trace middleware explicitly
        // Other middleware...
        // Note: Internal logging picks up trace ID if EnableTraceLogging is true
    },
    // Other configuration...
}
r := router.NewRouter[string, string](routerConfig, authFunction, userIdFromUserFunction) // Assume auth funcs exist
```

## Accessing the Trace ID

Once enabled (either automatically via `TraceIDBufferSize` or explicitly via middleware), you can retrieve the trace ID within your handlers or other middleware using helper functions from the `pkg/scontext` package.

### `scontext.GetTraceIDFromRequest`

This function retrieves the trace ID from the `http.Request` object's context. It requires the router's `UserIDType` and `UserObjectType` as type parameters.

```go
import (
	"fmt"
	"net/http"
	"github.com/Suhaibinator/SRouter/pkg/scontext" // Use scontext package
	// "go.uber.org/zap" // Uncomment if using zap logger example
)


func myHandler(w http.ResponseWriter, r *http.Request) {
    // Get the trace ID associated with this request
    // Replace string, any with your router's actual UserIDType, UserObjectType
    traceID := scontext.GetTraceIDFromRequest[string, any](r)

    // Use the trace ID, e.g., in custom logging or downstream requests
    fmt.Printf("[trace_id=%s] Handling request for %s\n", traceID, r.URL.Path)

    // You can also add it to your own structured logs
    // logger.Info("Processing request", zap.String("trace_id", traceID), ...)

    // ... rest of handler logic ...
    w.Write([]byte("Handled with trace ID: " + traceID))
}
```

### `scontext.GetTraceIDFromContext`

If you only have access to the `context.Context` (e.g., in a function called by your handler), you can use this function. It also requires the router's `UserIDType` and `UserObjectType` as type parameters.

```go
import (
	"context"
	"fmt"
	"log"
	"net/http"

	"github.com/Suhaibinator/SRouter/pkg/scontext" // Use scontext package
)

func processData(ctx context.Context, data string) {
    // Get the trace ID from the context passed down from the handler
    // Replace string, any with your router's actual UserIDType, UserObjectType
    traceID := scontext.GetTraceIDFromContext[string, any](ctx)

    // Use the trace ID in logs or further processing
    log.Printf("[trace_id=%s] Processing data: %s\n", traceID, data)

    // ... processing logic ...
}

// In your handler:
func myHandlerWithContext(w http.ResponseWriter, r *http.Request) {
    // Replace string, any with your router's actual UserIDType, UserObjectType
    traceID := scontext.GetTraceIDFromRequest[string, any](r) // Get it from request
    fmt.Printf("[trace_id=%s] Handler started\n", traceID)

    // Pass the request's context (which contains the trace ID) to downstream functions
    processData(r.Context(), "some data")

    w.Write([]byte("Processed data with trace ID: " + traceID))
}

```

## Propagating the Trace ID

To maintain a consistent trace across multiple services, you should propagate the trace ID when making requests to downstream services. This is typically done by adding the trace ID as an HTTP header (e.g., `X-Trace-ID`).

```go
import (
	"net/http"

	"github.com/Suhaibinator/SRouter/pkg/scontext" // Use scontext package
)

func callDownstreamService(r *http.Request) (*http.Response, error) {
    // Get the trace ID from the incoming request
    // Replace string, any with your router's actual UserIDType, UserObjectType
    traceID := scontext.GetTraceIDFromRequest[string, any](r)

    // Create a new request to the downstream service
    downstreamReq, err := http.NewRequestWithContext(r.Context(), "GET", "http://downstream-service/api/data", nil)
    if err != nil {
        return nil, err
    }

    // Add the trace ID to the outgoing request's headers
    if traceID != "" {
        downstreamReq.Header.Set("X-Trace-ID", traceID) // Common header name
    }

    // Make the request
    client := &http.Client{} // Use a shared client in real applications
    resp, err := client.Do(downstreamReq)

    // Handle response and error
    // ...

    return resp, err
}
```

The downstream service should then be configured to look for this header, extract the trace ID, and use it for its own logging and further propagation.

See the `examples/trace-logging` directory for a runnable example.
